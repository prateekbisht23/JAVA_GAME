package com.prateekbisht.gaming;

import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.image.BufferedImage;
import java.io.IOException;

import javax.imageio.ImageIO;
import javax.swing.JPanel;
import javax.swing.Timer;

import com.prateekbisht.gaming.sprites.Enemy;
import com.prateekbisht.gaming.sprites.Player;

public class Board extends JPanel {

    Timer timer;
    BufferedImage backgroundImage;
    BufferedImage buffer; // Offscreen buffer for double buffering

    Player player;
    Enemy enemies[] = new Enemy[3];

    public Board() {
        setSize(1400, 800);
        loadBackgroundImage();
        player = new Player();
        loadEnemies();
        gameLoop();
        setFocusable(true);
        bindEvents();

        // Create the buffer image to match the panel size
        buffer = new BufferedImage(1400, 800, BufferedImage.TYPE_INT_ARGB);
    }

    private void gameOver(Graphics pen) {
        if (player.outOfScreen()) {
            pen.setFont(new Font("times", Font.BOLD, 50));
            pen.setColor(Color.RED);
            pen.drawString("You Won", 600, 300);
            timer.stop();
        }

        for (Enemy enemy : enemies) {
            if (isCollide(enemy)) {
                pen.setFont(new Font("times", Font.BOLD, 50));
                pen.setColor(Color.RED);
                pen.drawString("Game Over", 550, 300);
                timer.stop();
            }
        }
    }

    private boolean isCollide(Enemy enemy) {
        int xDistance = Math.abs(player.getX() - enemy.getX());
        int yDistance = Math.abs(player.getY() - enemy.getY());

        int maxH = Math.max(player.getH(), enemy.getH());
        int maxW = Math.max(player.getW(), enemy.getW());

        return xDistance <= maxW - 80 && yDistance <= maxH - 120;
    }

    private void bindEvents() {
        addKeyListener(new KeyListener() {

            @Override
            public void keyTyped(KeyEvent e) {}

            @Override
            public void keyReleased(KeyEvent e) {
                player.setSpeed(0);
            }

            @Override
            public void keyPressed(KeyEvent e) {
                if (e.getKeyCode() == KeyEvent.VK_RIGHT) {
                    player.setSpeed(5);
                } else if (e.getKeyCode() == KeyEvent.VK_LEFT) {
                    player.setSpeed(-5);
                }
            }
        });
    }

    private void loadEnemies() {
        int x = 300;
        int speed = 2;
        for (int i = 0; i < enemies.length; i++) {
            enemies[i] = new Enemy(x + (i * 400), speed + (i * 2));
        }
    }

    private void gameLoop() {
        timer = new Timer(16, (e) -> repaint());
        timer.start();
    }

    private void drawPlayer(Graphics pen) {
        player.draw(pen);
        player.move();
    }

    private void drawEnemies(Graphics pen) {
        for (Enemy enemy : enemies) {
            enemy.draw(pen);
            enemy.move();
        }
    }

    private void loadBackgroundImage() {
        try {
            backgroundImage = ImageIO.read(Board.class.getResource("GameBG.jpg"));
        } catch (IOException e) {
            System.out.println("Background Image Not Found...");
            System.exit(1);
            e.printStackTrace();
        }
    }

    @Override
    public void paintComponent(Graphics g) {
        super.paintComponent(g);

        // Get graphics context of the buffer
        Graphics2D bufferGraphics = buffer.createGraphics();

        // Clear the buffer for new frame (optional, depends on animation)
        bufferGraphics.clearRect(0, 0, buffer.getWidth(), buffer.getHeight());

        // Draw the background, player, enemies, and game over text onto the buffer
        bufferGraphics.drawImage(backgroundImage, 0, 0, 1400, 800, null);
        drawPlayer(bufferGraphics);
        drawEnemies(bufferGraphics);
        gameOver(bufferGraphics);

        // Draw the buffer to the panel's graphics context
        g.drawImage(buffer, 0, 0, null);

        // Dispose of buffer graphics to free up resources
        bufferGraphics.dispose();
    }
}
